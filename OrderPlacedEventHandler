package com.klarna.sw.ai.mood.handlers;

import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_ACQUIRING_CONTRACT_ENTITY;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_ACQUIRING_SOURCE;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_BILLING_COUNTRY;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_EXP_PLATFORM_RESULT;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_ISSUING_CONTRACT_ENTITY;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_ISSUING_SYSTEM;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_IS_AI_ORDER;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_IS_DISCOUNT_PRESENT;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_MERCHANT_ID;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_ORDER_USE_CASE;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_PAYMENT_METHOD;
import static com.klarna.sw.ai.library.service.EventListenerMetricService.TAG_PROCESSOR;
import static com.klarna.sw.ai.mood.handlers.dto.OrderUseCase.WITH_PERSONA_ID_CALCULATION;
import static com.klarna.sw.ai.mood.service.ExpPlatformFeature.AI_FILTERS;
import static com.klarna.sw.ai.mood.service.ExpPlatformFeatureConfigKey.FIXED_TERMS_OWNER;
import static com.klarna.sw.ai.mood.service.ExpPlatformFeatureConfigKey.PERSONA_CALCULATED_ROLLOUT_KEY;
import static com.klarna.sw.ai.mood.util.FundingSourceUtils.generateFundingSourcesFromOrderPlacedEvent;
import static net.logstash.logback.argument.StructuredArguments.kv;

import com.klarna.mood.events.EventMetadata;
import com.klarna.sw.ai.library.integration.sal.model.Acquirer;
import com.klarna.sw.ai.library.integration.sal.model.AcquirerDiscount;
import com.klarna.sw.ai.library.integration.sal.model.AcquirerDiscount.AcquirerDiscountBuilder;
import com.klarna.sw.ai.library.integration.sal.model.AcquiringFee;
import com.klarna.sw.ai.library.integration.sal.model.AuthorizationResponseBody;
import com.klarna.sw.ai.library.integration.sal.model.ContractEntities;
import com.klarna.sw.ai.library.integration.sal.model.CreateAuthorizationRequestBody;
import com.klarna.sw.ai.library.integration.sal.model.CreditCard;
import com.klarna.sw.ai.library.integration.sal.model.EntityIdentifier;
import com.klarna.sw.ai.library.integration.sal.model.Fee;
import com.klarna.sw.ai.library.integration.sal.model.FeeType;
import com.klarna.sw.ai.library.integration.sal.model.FundingSource;
import com.klarna.sw.ai.library.integration.sal.model.Identifier;
import com.klarna.sw.ai.library.integration.sal.model.Identifier.IdentifierTypeEnum;
import com.klarna.sw.ai.library.integration.sal.model.Money;
import com.klarna.sw.ai.library.integration.sal.model.MoodContract;
import com.klarna.sw.ai.library.integration.sal.model.MoodContract.MoodContractBuilder;
import com.klarna.sw.ai.library.integration.sal.model.MoodFinancialProduct;
import com.klarna.sw.ai.library.integration.sal.model.NonServicingMoodConsumer;
import com.klarna.sw.ai.library.integration.sal.model.NonServicingMoodConsumer.NonServicingMoodConsumerBuilder;
import com.klarna.sw.ai.library.integration.sal.model.NonServicingMoodContactInformation;
import com.klarna.sw.ai.library.integration.sal.model.NonServicingMoodPayment;
import com.klarna.sw.ai.library.integration.sal.model.NonServicingMoodSeller;
import com.klarna.sw.ai.library.integration.sal.model.OrderLine;
import com.klarna.sw.ai.library.integration.sal.model.PaymentMethod;
import com.klarna.sw.ai.library.integration.sal.model.PaymentOptions;
import com.klarna.sw.ai.library.integration.sal.model.ShippingAddress;
import com.klarna.sw.ai.library.integration.sal.model.SliceItByCard;
import com.klarna.sw.ai.library.quarantine.dao.FilterItemIssuingSystem;
import com.klarna.sw.ai.library.service.EventListenerMetricService;
import com.klarna.sw.ai.library.service.TermsOwnerService;
import com.klarna.sw.ai.library.service.filter.BaseFilter;
import com.klarna.sw.ai.library.service.termsowner.TermsOwner;
import com.klarna.sw.ai.library.service.termsowner.TermsOwnerSpecification;
import com.klarna.sw.ai.library.util.LoggingUtils;
import com.klarna.sw.ai.library.util.exception.AuthorizationNotFoundException;
import com.klarna.sw.ai.library.util.exception.IdempotencyException;
import com.klarna.sw.ai.library.util.exception.InvalidTermsOwnerException;
import com.klarna.sw.ai.library.util.exception.SchemaValidationException;
import com.klarna.sw.ai.mood.handlers.dto.OrderPlacedEventHandlerHelperRequestSpec;
import com.klarna.sw.ai.mood.handlers.dto.OrderPlacedEventHandlerHelperResponseSpec;
import com.klarna.sw.ai.mood.handlers.dto.OrderUseCase;
import com.klarna.sw.ai.mood.handlers.dto.context.EventContextRequest;
import com.klarna.sw.ai.mood.handlers.dto.context.EventHandlerResponse;
import com.klarna.sw.ai.mood.handlers.feehandlers.FeeHandler;
import com.klarna.sw.ai.mood.handlers.feehandlers.dto.FeeDto;
import com.klarna.sw.ai.mood.handlers.feehandlers.dto.FeeHandlerRequestDto;
import com.klarna.sw.ai.mood.helper.OrderPlacedEventHandlerHelper;
import com.klarna.sw.ai.mood.model.mood.drafts.events.OrderPlacedEventDraft;
import com.klarna.sw.ai.mood.service.ExpPlatformRequestDto;
import com.klarna.sw.ai.mood.service.FeatureConfigDto;
import com.klarna.sw.ai.mood.util.AiFeature;
import com.klarna.sw.ai.mood.util.Marker;
import com.klarna.sw.ai.mood.util.OrderLineUtils;
import com.klarna.sw.ai.mood.util.OrderUtils;
import com.klarna.sw.ai.mood.util.PaymentMethodType;
import com.klarna.sw.ai.mood.util.dto.FundingSourcesInput;
import java.time.Clock;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;


@Component(OrderPlacedEventDraft.EVENT_TYPE)
@Slf4j
@RequiredArgsConstructor
public final class OrderPlacedEventHandler
    extends AbstractMoodEventHandler {

  private static final int NO_DOWNPAYMENT_DONE = 0;
  private static final int NO_INFO_ABOUT_SHIPPING_DELAY = 0;
  private static final String MOOD_ACQUIRING_SYSTEM = "mood";
  private static final String ENTITY_UNKNOWN = "UNKNOWN";
  private static final String PROCESSOR_AI = "ai";

  public static final String PERSONA_ID = "persona_id";
  public static final String PERSONA_ID_VALUE = "persona_id_value";
  public static final String TAG_PAYMENT_METHOD_DIFF = "difference_in_payment_method";

  @NonNull
  private final EventListenerMetricService metrics;
  @NonNull
  @Getter
  private TermsOwnerService termsOwnerService;
  @NonNull
  private OrderPlacedEventHandlerHelper helper;
  @NonNull
  private FeeHandler feeHandler;
  @NonNull
  private BaseFilter eventFilter;
  @NonNull
  private Clock clock;
  @Value("${slice-it-by-card.v2.enabled}")
  private boolean isSliceItByCardV2Enabled;

  @Value("${acquirers-importer.handle-all-traffic.enabled}")
  private boolean handleAllTraffic;

  @SneakyThrows
  @Override
  public EventHandlerResponse handle(EventContextRequest request) {

    EventMetadata eventMetadata = request.getEventMetadata();

    OrderPlacedEventDraft event = (OrderPlacedEventDraft) request.getBaseEvent();
    log.info("Processing OrderPlacedEvent");

    final String contractType = "MOOD";

    var eventOpt = Optional.ofNullable(event);

    String acquiringSource = eventOpt.map(ev -> ev.acquiring_source).orElse(null);

    FeeHandlerRequestDto feeHandlerRequestDto = feeHandler.intializeFeeHandlerRequestDto(request, null,
        new ArrayList<>(), false);

    FeeDto feeDto = feeHandler.handleFee(feeHandlerRequestDto);

    List<AcquiringFee> acquiringFees = OrderUtils.convertFeeAdditionsDtoToAcquiringFees(feeDto);

    Optional<Fee> acquiringDiscount = feeDto.getFeeAdditions().stream()
        .filter(fee -> FeeType.ACQUIRING_DISCOUNT.equals(fee.getFeeType()))
        .findFirst();

    boolean isDiscountPresent = acquiringDiscount.isPresent();
    AcquirerDiscountBuilder discountBuilder = AcquirerDiscount.builder();

    acquiringDiscount.ifPresent(discount -> discountBuilder.estimatedAmount(discount.getInitialAmount())
        .krn(discount.getExternalId()));

    var orderId =
        eventOpt
            .map(ev -> ev.order_id)
            .orElseThrow(() -> new SchemaValidationException("order_id is null"));
    var orderKrn =
        eventOpt
            .map(ev -> ev.order_krn)
            .orElseThrow(() -> new SchemaValidationException("order_krn is null"));
    var orderAmount =
        eventOpt
            .map(ev -> ev.order_amount)
            .orElseThrow(() -> new SchemaValidationException("order_amount is null"));
    String purchaseCurrency =
        eventOpt
            .map(ev -> ev.purchase_currency)
            .orElseThrow(() -> new SchemaValidationException("purchase_currency is null"));
    var correlationId =
        Optional.ofNullable(eventMetadata)
            .map(em -> em.correlation_id)
            .orElse(UUID.randomUUID().toString());
    String initialPaymentMethodType =
        eventOpt.map(em -> em.selected_payment_method).map(pm -> pm.type).orElse(null);

    var paymentMethodType =
        eventOpt
            .map(ev -> ev.payment_method_type)
            .orElseThrow(() -> new SchemaValidationException("payment_method_type is null"));

    String merchantId =
        eventOpt
            .map(ev -> ev.merchant_id)
            .orElseThrow(() -> new SchemaValidationException("merchant_id is null"));

    Integer numberOfDays =
        eventOpt
            .map(ev -> ev.selected_payment_method)
            .map(selectedPaymentMethod -> selectedPaymentMethod.number_of_days)
            .orElse(null);

    String metadataIssuingSystem = OrderUtils.getIssuingSystem(eventMetadata);
    FilterItemIssuingSystem filterIssuingSystem = FilterItemIssuingSystem.valueOf(metadataIssuingSystem);
    String issuingSystem = filterIssuingSystem.name().toLowerCase();

    long authorizationCreatedAt = OffsetDateTime.now(clock).toInstant().toEpochMilli();

    String billingAddressCountry =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.country)
            .orElseThrow(() -> new NullPointerException("billing_address_country is null"));

    metrics.countEvent(
        eventMetadata.event_type, issuingSystem, billingAddressCountry, paymentMethodType);

    String issuingContractEntity =
        eventOpt
            .map(em -> em.contract_entities)
            .map(contractEntity -> contractEntity.issuing_contract_entity)
            .orElse(ENTITY_UNKNOWN);

    issuingContractEntity =
        issuingContractEntity.isBlank() ? ENTITY_UNKNOWN : issuingContractEntity;

    String acquiringContractEntity =
        eventOpt
            .map(em -> em.contract_entities)
            .map(contractEntity -> contractEntity.acquiring_contract_entity)
            .orElse(ENTITY_UNKNOWN);

    acquiringContractEntity =
        acquiringContractEntity.isBlank() ? ENTITY_UNKNOWN : acquiringContractEntity;
    String personaId = eventOpt.map(ev -> ev.consumer).map(consumer -> consumer.persona_id).orElse(null);
    boolean shouldBeProcessedByAi = handleAllTraffic;

    //result of exp-platform call
    FeatureConfigDto featureConfigDto = null;
    //optional result of personaId rollout calculation
    Optional<Boolean> personaExpResult = Optional.empty();
    OrderUseCase orderUseCase = OrderUseCase.REGULAR;
    if (!shouldBeProcessedByAi) {
      ExpPlatformRequestDto expPlatformRequestDto = ExpPlatformRequestDto.build(AI_FILTERS.getKey(), correlationId,
          stage,
          region,
          orderKrn,
          paymentMethodType,
          issuingSystem,
          billingAddressCountry,
          eventMetadata.event_type,
          event.merchant_id.toUpperCase(),
          numberOfDays,
          personaId);
      featureConfigDto = experimentationPlatformService.fetchFeatureConfigDto(expPlatformRequestDto);
      if (featureConfigDto.isEnabled()) {
        shouldBeProcessedByAi = true;
        Map<String, String> featureConfig = featureConfigDto.getConfig();
        if (featureConfig != null && featureConfig.containsKey(PERSONA_CALCULATED_ROLLOUT_KEY)) {
          orderUseCase = WITH_PERSONA_ID_CALCULATION;
        }
      }
    }

    List<Identifier> listOfCustomerIdentifiers = new ArrayList<>();

    String consumerBalanceOwner = eventOpt.map(ev -> ev.selected_payment_method)
        .map(spm -> spm.consumer_balance_owner)
        .orElse(null);
    OrderPlacedEventHandlerHelperRequestSpec helperRequest = OrderPlacedEventHandlerHelperRequestSpec.builder()
        .orderUseCase(orderUseCase).personaId(personaId)
        .featureConfigDto(featureConfigDto)
        .issuingContext(event.issuing_context)
        .consumerBalanceOwner(consumerBalanceOwner)
        .paymentMethodType(paymentMethodType).build();

    //if order is pre-assigned to AI we need to check if it's not one of special use cases we should actually forward
    if (shouldBeProcessedByAi) {
      OrderPlacedEventHandlerHelperResponseSpec helperResponse = helper.checkForExceptionalScenarios(helperRequest);
      orderUseCase = helperResponse.getOrderUseCase();
      shouldBeProcessedByAi = helperResponse.isShouldBeProcessedByAi();
      personaExpResult = helperResponse.getPersonaExpResult();
    }

    String financialTermsOwner = null;
    if (shouldBeProcessedByAi) {
      if (featureConfigDto != null && featureConfigDto.getConfig() != null && featureConfigDto.getConfig()
          .containsKey(FIXED_TERMS_OWNER)) {
        financialTermsOwner = featureConfigDto.getConfig().get(FIXED_TERMS_OWNER);
        if (!TermsOwner.isValidTermsOwner(financialTermsOwner)) {
          throw new InvalidTermsOwnerException("Unsupported terms owner: " + financialTermsOwner);
        }
      } else { //default approach
        TermsOwnerSpecification termsOwnerSpec =
            TermsOwnerSpecification.builder()
                .issuingSystem(filterIssuingSystem)
                .purchaseCountry(event.purchase_country)
                .paymentMethod(PaymentMethod.valueOf(event.payment_method_type.toUpperCase()))
                .initialPaymentMethodType(initialPaymentMethodType)
                .build();
        financialTermsOwner = termsOwnerService.getTermsOwner(termsOwnerSpec);
      }
    }
    // »»»»» log result of final processing decision in one place

    // expPlatformResultString :: in case we don't need to call exp platform we would set it to SKIPPED,
    // otherwise it can have values depending on results from possible both exp-platform calls, so it can be any of:
    // true, false, true_true, true_false
    String expPlatformResultString =
        featureConfigDto == null ? "SKIPPED" : featureConfigDto.isEnabled() ? "true" : "false";
    if (personaExpResult.isPresent()) {
      expPlatformResultString += personaExpResult.get().booleanValue() ? "_true" : "_false";
    }
    String processor = shouldBeProcessedByAi ? PROCESSOR_AI : issuingSystem;

    MDC.put(TAG_EXP_PLATFORM_RESULT, expPlatformResultString);
    MDC.put(TAG_ISSUING_SYSTEM, issuingSystem.toLowerCase());
    MDC.put(TAG_PAYMENT_METHOD, paymentMethodType.toUpperCase());
    MDC.put(TAG_BILLING_COUNTRY, billingAddressCountry.toLowerCase());
    MDC.put(TAG_MERCHANT_ID, merchantId.toUpperCase());
    MDC.put(TAG_IS_DISCOUNT_PRESENT, Boolean.toString(isDiscountPresent));
    MDC.put(TAG_ISSUING_CONTRACT_ENTITY, issuingContractEntity);
    MDC.put(TAG_ACQUIRING_CONTRACT_ENTITY, acquiringContractEntity);
    MDC.put(TAG_IS_AI_ORDER, Boolean.toString(shouldBeProcessedByAi));
    MDC.put(TAG_PROCESSOR, processor);
    MDC.put(TAG_ORDER_USE_CASE, orderUseCase.name());
    MDC.put(PERSONA_ID, personaId);
    MDC.put(TAG_ACQUIRING_SOURCE, acquiringSource);
    
    log.info(Marker.ONE_TIME_ORDER_MARKER);

    metrics.countOrderPlacedDetails(shouldBeProcessedByAi, processor, paymentMethodType, acquiringSource, issuingSystem,
        issuingContractEntity,
        acquiringContractEntity,
        billingAddressCountry.toUpperCase(), isDiscountPresent, expPlatformResultString, orderUseCase.name(),
        financialTermsOwner == null ? "" : financialTermsOwner);

    // if we know order shouldn't be processed by AI we return false
    if (!shouldBeProcessedByAi) {
      return EventHandlerResponse.builder().handled(false).build();
    }

    if (initialPaymentMethodType != null && !initialPaymentMethodType.equals(event.payment_method_type)) {
      metrics.countCustomMetric(TAG_PAYMENT_METHOD_DIFF, event.payment_method_type + ":" + initialPaymentMethodType, 1);
      log.info("initialPaymentMethodType and payment_method_type did not match",
          kv("initialPaymentMethodType", initialPaymentMethodType),
          kv("payment_method_type", event.payment_method_type));
    }

    listOfCustomerIdentifiers.add(
        Identifier.builder()
            .identifierType(IdentifierTypeEnum.PERSONA_ID)
            .identifierValue(personaId)
            .build());
    //TODO :: to be dropped after sync with TX
    listOfCustomerIdentifiers.add(
        Identifier.builder()
            .identifierType(IdentifierTypeEnum.PERSONA)
            .identifierValue(personaId)
            .build());

    MoodContract.MoodContractBuilder contractBuilder = MoodContract.builder();
    if (isDiscountPresent) {
      AcquirerDiscount acquirerDiscount = discountBuilder
          //temporary solution to hard code the discount type as PROPORTIONAL_CASHBACK and rate and max value as 0. This should be removed once
          // SAL-3774, TXD-4308 and KRED-14072 are implemented
          .maxAmount(0)
          .rate(0)
          .type("PROPORTIONAL_CASHBACK")
          .build();
      contractBuilder =
          contractBuilder.acquirerDiscount(acquirerDiscount);
    }

    eventFilter.insertFilterItem(
        orderId,
        eventMetadata.event_id,
        filterIssuingSystem,
        paymentMethodType.toUpperCase(),
        authorizationCreatedAt,
        billingAddressCountry,
        acquiringSource,
        isDiscountPresent,
        false);

    log.info("FilterItem record created", LoggingUtils.mapOf(
        "orderId", orderId,
        "event_id", eventMetadata.event_id,
        "filter_issuing_system", filterIssuingSystem,
        "payment_method_type", paymentMethodType.toUpperCase(),
        "authorization_created_at", authorizationCreatedAt)
    );

    var streetAddress =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.street_address)
            .orElseThrow(() -> new NullPointerException("street_address is null"));

    var postalCode =
        eventOpt.map(em -> em.billing_address).map(billingAddress -> billingAddress.postal_code);

    var city =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.city)
            .orElseThrow(() -> new NullPointerException("city is null"));

    var givenName =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.given_name)
            .orElseThrow(() -> new NullPointerException("given_name is null"));

    var familyName =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.family_name)
            .orElseThrow(() -> new NullPointerException("family_name is null"));

    var phone =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.phone)
            .orElse("");

    var email =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.email)
            .orElseThrow(() -> new NullPointerException("email is null"));

    var expiresAt =
        eventOpt
            .map(em -> em.expires_at)
            .orElseThrow(() -> new NullPointerException("expires_at is null"));

    Long contractTypeIdFromEvent =
        eventOpt
            .map(ev -> ev.contract_type_id)
            .orElse(null);
    String contractTypeId = contractTypeIdFromEvent != null ? contractTypeIdFromEvent.toString() : null;

    var defaultDelay =
        eventOpt
            .map(ev -> ev.shipping_delay)
            .map(delay -> delay.default_delay)
            .orElse(NO_INFO_ABOUT_SHIPPING_DELAY);

    var transactionId =
        eventOpt
            .map(ev -> ev.psp)
            .map(rr -> rr.reconciliation_reference)
            .orElse("NO_TRANSACTION_ID submitted.");

    var downpaymentAmount =
        eventOpt
            .map(ev -> ev.selected_payment_method)
            .map(dpa -> dpa.downpayment_amount)
            .map(downpayment_amount -> downpayment_amount.intValue())
            .orElse(NO_DOWNPAYMENT_DONE);

    var monthlyDownpayments =
        eventOpt
            .map(ev -> ev.selected_payment_method)
            .map(selectedPaymentMethod -> selectedPaymentMethod.monthly_downpayments)
            .orElse(null);

    var numberOfMonths =
        eventOpt
            .map(ev -> ev.selected_payment_method)
            .map(selectedPaymentMethod -> selectedPaymentMethod.number_of_months)
            .orElse(null);

    var selectPaymentMethodFlags =
        eventOpt
            .map(ev -> ev.selected_payment_method)
            .map(selectedPaymentMethod -> selectedPaymentMethod.selected_payment_method_flags)
            .orElse(null);

    String mandateId =
        eventOpt
            .map(ev -> ev.selected_payment_method)
            .map(selectedPaymentMethod -> selectedPaymentMethod.mandate_id)
            .orElse(null);

    var captureStrategy =
        eventOpt
            .map(ev -> ev.selected_payment_method)
            .map(selectedPaymentMethod -> selectedPaymentMethod.captureStrategy)
            .orElse(null);

    var contractId =
        eventOpt.map(ev -> ev.psp).map(ci -> ci.contract_id).orElse("NO PSP contract_id submitted");

    var gatewayReference =
        eventOpt
            .map(ev -> ev.psp)
            .map(gr -> gr.gateway_reference)
            .orElse(null);

    // SHIPPING ADDRESS
    var shippingAddressStreetAddress =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.street_address)
            .orElseThrow(() -> new NullPointerException("shipping_address.street_address is null"));

    var shippingAddressPostalCode =
        eventOpt.map(em -> em.shipping_address).map(shippingAddress -> shippingAddress.postal_code);

    var shippingAddressCity =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.city)
            .orElseThrow(() -> new NullPointerException("shipping_address.city is null"));

    var shippingAddressGivenName =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.given_name)
            .orElseThrow(() -> new NullPointerException("shipping_address.given_name is null"));

    var shippingAddressFamilyName =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.family_name)
            .orElseThrow(() -> new NullPointerException("shipping_address.family_name is null"));

    var shippingAddressPhone =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.phone)
            .orElse("");

    var shippingAddressEmail =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.email)
            .orElse("");

    var shippingAddressCountry =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.country)
            .orElseThrow(() -> new NullPointerException("shipping_address.country is null"));

    var shippingAddressStreetAddress2 =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.street_address2)
            .orElse(null);

    var shippingAddressTitle =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.title)
            .orElse(null);

    var shippingAddressRegion =
        eventOpt
            .map(em -> em.shipping_address)
            .map(shippingAddress -> shippingAddress.region)
            .orElse(null);

    var installmentAmount =
        eventOpt
            .map(em -> em.payment_options)
            .map(paymentOptions -> paymentOptions.installment_amount)
            .map(installment_amount -> installment_amount.intValue())
            .orElse(null);

    var apr =
        eventOpt
            .map(em -> em.payment_options)
            .map(paymentOptions -> paymentOptions.apr)
            .map(aprVal -> aprVal.intValue())
            .orElse(null);

    var clientPaymentReference =
        eventOpt.map(em -> em.psp).map(psp -> psp.client_payment_reference).orElse(null);

    var connector = eventOpt.map(em -> em.psp).map(psp -> psp.connector).orElse(null);

    var connectorReference =
        eventOpt.map(em -> em.psp).map(psp -> psp.connector_reference).orElse(null);

    var capturedAmount =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.captured_amount)
            .map(captured_amount -> captured_amount.intValue())
            .orElse(0);

    var authorizedAmount =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.authorized_amount)
            .map(authorized_amount -> authorized_amount.intValue())
            .orElse(null);

    // CREDIT CARD
    var creditCardNumber =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.credit_card)
            .map(creditCard -> creditCard.card_number)
            .orElse(null);
    var creditCardBrand =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.credit_card)
            .map(creditCard -> creditCard.brand)
            .orElse(null);
    var creditCardExpirationYear =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.credit_card)
            .map(creditCard -> creditCard.expiration_year)
            .orElse(null);
    var creditCardExpirationMonth =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.credit_card)
            .map(creditCard -> creditCard.expiration_month)
            .orElse(null);
    var creditCardHolder =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.credit_card)
            .map(creditCard -> creditCard.holder)
            .orElse(null);
    var creditCardCardTransactionType =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.credit_card)
            .map(creditCard -> creditCard.card_transaction_type)
            .orElse(null);
    var creditCardToken =
        eventOpt
            .map(em -> em.psp)
            .map(psp -> psp.credit_card)
            .map(creditCard -> creditCard.token)
            .orElse(null);

    var merchantData = eventOpt.map(em -> em.merchant_data).orElse(null);

    boolean anyCreditCardDetailAvailable =
        Arrays.asList(
                creditCardNumber,
                creditCardBrand,
                creditCardExpirationYear,
                creditCardExpirationMonth,
                creditCardHolder,
                creditCardCardTransactionType,
                creditCardToken)
            .stream()
            .anyMatch(Objects::nonNull);

    CreditCard creditCard = null;

    if (anyCreditCardDetailAvailable) {
      creditCard =
          CreditCard.builder()
              .cardNumber(creditCardNumber)
              .brand(creditCardBrand)
              .expirationYear(creditCardExpirationYear)
              .expirationMonth(creditCardExpirationMonth)
              .holder(creditCardHolder)
              .cardTransactionType(creditCardCardTransactionType)
              .token(creditCardToken)
              .build();
    }

    PaymentOptions paymentOptions =
        PaymentOptions.builder().installmentAmount(installmentAmount).apr(apr).build();

    List<OrderLine> orderLines =
        OrderLineUtils.generateSalOrderLines(event.order_lines, event.purchase_currency);

    Optional<String> cidValue = Optional.empty();
    if (event.issuing_context != null && event.issuing_context.additional_information != null) {
      Optional<LinkedHashMap<String, String>> decision_context =
          ((HashMap<String, LinkedHashMap<String, String>>)
              event.issuing_context.additional_information)
              .entrySet().stream()
              .filter(e -> e.getKey().equals("decision_context"))
              .map(Entry::getValue)
              .findAny();

      if (decision_context.isPresent()) {
        cidValue =
            decision_context.get().entrySet().stream()
                .filter(e -> e.getKey().equals("cid"))
                .map(Entry::getValue)
                .findAny();

        if (cidValue.isPresent()) {
          Identifier customerCid =
              Identifier.builder()
                  .identifierType(IdentifierTypeEnum.CUSTOMER_ID)
                  .identifierValue(cidValue.get())
                  .build();
          listOfCustomerIdentifiers.add(customerCid);
        }
      }
    }

    var userAccountId =
        eventOpt
            .map(ev -> ev.customer_identifiers)
            .map(customer_identifiers -> customer_identifiers.getUserAccountId())
            .orElse(null);

    if (userAccountId != null) {
      listOfCustomerIdentifiers.add(
          Identifier.builder()
              .identifierType(IdentifierTypeEnum.USER_ACCOUNT_ID)
              .identifierValue(userAccountId)
              .build());
      //TODO :: to be dropped after sync with TX
      listOfCustomerIdentifiers.add(
          Identifier.builder()
              .identifierType(IdentifierTypeEnum.USER_ACCOUNT)
              .identifierValue(userAccountId)
              .build());
    }

    var userAccountKrn =
        eventOpt
            .map(ev -> ev.customer_identifiers)
            .map(customer_identifiers -> customer_identifiers.getUserAccountKrn())
            .orElse(null);

    if (userAccountKrn != null) {
      listOfCustomerIdentifiers.add(
          Identifier.builder()
              .identifierType(Identifier.IdentifierTypeEnum.USER_ACCOUNT_KRN)
              .identifierValue(userAccountKrn)
              .build());
    }

    if (listOfCustomerIdentifiers.size() == 0) {
      throw new SchemaValidationException("At least one valid customer identifier is required");
    }

    Money amount =
        Money.builder().currency(purchaseCurrency).amount(orderAmount.intValue()).build();
    NonServicingMoodSeller seller =
        NonServicingMoodSeller.builder()
            .name(StringUtils.EMPTY)
            .id(merchantId)
            .merchantReference1(event.merchant_reference1)
            .merchantReference2(event.merchant_reference2)
            .build();
    boolean isDownpaymentDone = downpaymentAmount > 0;

    Optional<java.time.Period> establishmentPeriodOpt =
        eventOpt
            .map(em -> em.selected_payment_method)
            .map(selectedPaymentMethod -> selectedPaymentMethod.establishment_period);

    MoodFinancialProduct financialProduct = null;
    if (paymentMethodType.equals(PaymentMethodType.SLICE_IT_BY_CARD.getType())
        && isSliceItByCardV2Enabled
        && establishmentPeriodOpt.isPresent()) {

      financialProduct =
          SliceItByCard.builder()
              .financialProductType(SliceItByCard.FinancialProductTypeEnum.SLICE_IT_BY_CARD)
              .financialProductId(contractTypeId)
              .establishmentPeriod(establishmentPeriodOpt.get().toString())
              .build();
    } else {

      Integer numberOfInstallments = event.selected_payment_method.number_of_installments;
      Integer creditTimeinDays = event.selected_payment_method.number_of_days;

      financialProduct =
          MoodFinancialProduct.builder(
              paymentMethodType.toUpperCase(),
              contractTypeId,
              numberOfInstallments,
              creditTimeinDays,
              captureStrategy);
    }

    contractBuilder.financialProductTermsOwner(financialTermsOwner);

    String orderLevelLiability =
        eventOpt
            .map(em -> em.selected_payment_method)
            .map(selectedPaymentMethod -> selectedPaymentMethod.order_level_liability)
            .orElse(null);

    String dateOfBirth =
        eventOpt
            .map(ev -> ev.consumer)
            .map(consumer -> consumer.date_of_birth)
            .map(dtBirth -> dtBirth.toString())
            .orElse(null);

    Integer lastFourSsn =
        eventOpt
            .map(ev -> ev.consumer)
            .map(consumer -> consumer.last_four_ssn)
            .map(lastFourSsnString -> Integer.valueOf(lastFourSsnString))
            .orElse(null);

    String title =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.title)
            .orElse(null);

    String streetAddress2 =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.street_address2)
            .orElse(null);

    String region =
        eventOpt
            .map(em -> em.billing_address)
            .map(billingAddress -> billingAddress.region)
            .orElse(null);

    NonServicingMoodContactInformation.NonServicingMoodContactInformationBuilder
        billingAddressBuilder = NonServicingMoodContactInformation.builder();
    billingAddressBuilder
        .streetAddress(OrderUtils.removeUnicodeCharacters(streetAddress))
        .city(city)
        .givenName(OrderUtils.removeUnicodeCharacters(givenName))
        .familyName(OrderUtils.removeUnicodeCharacters(familyName))
        .email(OrderUtils.removeUnicodeCharacters(email))
        .country(billingAddressCountry)
        .dateOfBirth(dateOfBirth)
        .lastFourSsn(lastFourSsn)
        .title(title)
        .phone(phone)
        .streetAddress2(OrderUtils.removeUnicodeCharacters(streetAddress2))
        .region(OrderUtils.removeUnicodeCharacters(region));

    if (postalCode.isPresent()) {
      billingAddressBuilder.postalCode(postalCode.get());
    }

    ShippingAddress.ShippingAddressBuilder shippingAddressBuilder = ShippingAddress.builder();
    shippingAddressBuilder
        .streetAddress(OrderUtils.removeUnicodeCharacters(shippingAddressStreetAddress))
        .city(OrderUtils.removeUnicodeCharacters(shippingAddressCity))
        .givenName(OrderUtils.removeUnicodeCharacters(shippingAddressGivenName))
        .familyName(OrderUtils.removeUnicodeCharacters(shippingAddressFamilyName))
        .email(OrderUtils.removeUnicodeCharacters(shippingAddressEmail))
        .country(shippingAddressCountry)
        .streetAddress2(OrderUtils.removeUnicodeCharacters(shippingAddressStreetAddress2))
        .title(shippingAddressTitle)
        .phone(shippingAddressPhone)
        .region(OrderUtils.removeUnicodeCharacters(shippingAddressRegion));

    if (shippingAddressPostalCode.isPresent()) {
      shippingAddressBuilder.postalCode(shippingAddressPostalCode.get());
    }

    if (AiFeature.FUNDING_SOURCES.isEnabled()) {
      FundingSourcesInput.FundingSourcesInputBuilder fsib = FundingSourcesInput.builder()
          .mandateId(mandateId)
          .gatewayReference(gatewayReference)
          .creditCardToken(creditCardToken);
      if (initialPaymentMethodType != null && initialPaymentMethodType.toLowerCase().equals("klarna_bank_account")) {
        fsib.clientPaymentReference(clientPaymentReference);
      }
      List<FundingSource> fundingSources = generateFundingSourcesFromOrderPlacedEvent(fsib.build());
      if (fundingSources.size() > 0) {
        contractBuilder.fundingSources(fundingSources);
      }
    }

    contractBuilder
        .selectedPaymentMethodFlags(selectPaymentMethodFlags)
        .locale(event.locale)
        .purchaseStartedAt(event.purchase_started_at.toString())
        .purchaseFinishedAt(event.purchase_finished_at.toString())
        .contractType(MoodContract.ContractTypeEnum.valueOf(contractType))
        // open question default_delay or max_delay
        .shippingDelayInDays(defaultDelay)
        .address(billingAddressBuilder.build())
        .shippingAddress(shippingAddressBuilder.build())
        .payment(
            NonServicingMoodPayment.builder()
                .transactionId(transactionId)
                .downpayment(isDownpaymentDone)
                .amount(amount)
                .pspId(contractId)
                .gatewayReference(gatewayReference)
                .options(paymentOptions)
                .creditCard(creditCard)
                .monthlyDownpayments(monthlyDownpayments)
                .numberOfMonths(numberOfMonths)
                .downpaymentAmount(downpaymentAmount)
                .numberOfDays(numberOfDays)
                .clientPaymentReference(clientPaymentReference)
                .connector(connector)
                .connectorReference(connectorReference)
                .capturedAmount(capturedAmount)
                .authorizedAmount(authorizedAmount)
                .build())
        .financialProduct(financialProduct)
        .seller(seller)
        .klarnaReference(event.klarna_reference)
        .orderLevelLiability(orderLevelLiability)
        .orderLines(orderLines);

    addKredData(eventOpt, issuingSystem, merchantData, cidValue, contractBuilder, dateOfBirth);
    CreateAuthorizationRequestBody authRequest =
        CreateAuthorizationRequestBody.builder()
            .acquirer(
                Acquirer.builder().channel(acquiringSource).system(MOOD_ACQUIRING_SYSTEM).build())
            .expiresAt(expiresAt.toString())
            .externalIdentifier(EntityIdentifier.builder().id(orderId).krn(orderKrn).build())
            .country(billingAddressCountry)
            .customerIdentifiers(listOfCustomerIdentifiers)
            .amount(amount)
            .contractEntities(
                ContractEntities.builder()
                    .acquiringContractEntity(acquiringContractEntity)
                    .issuingContractEntity(issuingContractEntity)
                    .build())
            .contract(contractBuilder.build())
            .acquiringFees(acquiringFees)
            .build();

    ResponseEntity<AuthorizationResponseBody> authorization;
    try {
      authorization = salService.createAuthorization(authRequest, correlationId);
      if (!HttpStatus.CREATED.equals(authorization.getStatusCode())) {
        throw new AuthorizationNotFoundException(
            String.format(
                "Authorization not created" + "order_id=%s, amount=%s, correlation_id=%s",
                orderId, orderAmount, correlationId));
      }
      log.info(
          "Authorization created amount {}",
          kv("amount", orderAmount));
    } catch (IdempotencyException ex) {
      log.info(
          "Create authorization already processed {}",
          kv("order_krn", orderKrn));
    } catch (Exception e) {
      log.info("adding a dummy entry in the filter item table with aggregate ID");
      eventFilter.insertFilterItem(orderId,
          eventMetadata.event_id,
          filterIssuingSystem,
          null,
          // passing this as null because it is a dummy entry and correct values will be replaced when the event is replayed
          authorizationCreatedAt,
          billingAddressCountry,
          acquiringSource,
          false,
          // passing this as false because it is a dummy entry and correct values will be replaced when the event is replayed
          false
      );
      throw e;
    }
    return EventHandlerResponse.builder().handled(true).build();
  }


  private void addKredData(
      Optional<OrderPlacedEventDraft> eventOpt,
      String issuingSystem,
      String merchantData,
      Optional<String> cidValue,
      MoodContractBuilder contractBuilder,
      String dateOfBirth) {
    NonServicingMoodConsumerBuilder consumer;
    String nationalIdentNumber =
        eventOpt
            .map(ev -> ev.consumer)
            .map(cons -> cons.internal)
            .map(internal -> internal.national_identification_number)
            .orElse(null);

    String consumerType =
        eventOpt
            .map(ev -> ev.consumer)
            .map(cons -> cons.type)
            .map(String::toUpperCase)
            .orElse(null);

    consumer = NonServicingMoodConsumer.builder();
    consumer
        .consumerType(consumerType)
        .dateOfBirth(dateOfBirth)
        .nationalIdentificationNumber(nationalIdentNumber);
    if (cidValue.isPresent()) {
      consumer.customerId(cidValue.get());
    }
    if (consumer != null) {
      contractBuilder.consumer(consumer.build());
    }
    if (StringUtils.isNotEmpty(merchantData)) {
      contractBuilder.merchantData(merchantData);
    }
  }

  @Override
  public Class<OrderPlacedEventDraft> getOrderEventType() {
    return OrderPlacedEventDraft.class;
  }


  @Override
  public String getEventType() {
    return OrderPlacedEventDraft.EVENT_TYPE;
  }
}
